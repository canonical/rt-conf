package kcmd

import (
	"bufio"
	"fmt"
	"log"
	"os"
	"strings"

	"github.com/canonical/rt-conf/src/model"
	"github.com/canonical/rt-conf/src/utils"
)

// UpdateGrub reads GRUB_CMDLINE_LINUX_DEFAULT from the default GRUB configuration file,
// merges it with the kernel command line parameters specified in the provided config,
// and writes the resulting command line to a drop-in configuration file for GRUB.
func UpdateGrub(cfg *model.InternalConfig) ([]string, error) {
	if len(cfg.Data.KernelCmdline.Parameters) == 0 {
		return nil, fmt.Errorf("no parameters to inject")
	}

	if err := cfg.Data.KernelCmdline.HasDuplicates(); err != nil {
		return nil, fmt.Errorf("invalid new parameters: %v", err)
	}

	// Convert new parameters to Params for easier manipulation
	newParams := cfg.Data.KernelCmdline.ToParams()

	// Parse existing GRUB command line
	existingCmdlineStr, err := parseGrubCMDLineLinuxDefault(cfg.GrubCfg.GrubDefaultFilePath)
	if err != nil {
		return nil, fmt.Errorf("failed to parse %s grub file: %v", cfg.GrubCfg.GrubDefaultFilePath, err)
	}

	// Create KernelCmdline from existing string and validate
	existingCmdline := model.NewKernelCmdline(existingCmdlineStr)
	if err := existingCmdline.HasDuplicates(); err != nil {
		return nil, fmt.Errorf("invalid existing parameters in %s: %v", cfg.GrubCfg.GrubDefaultFilePath, err)
	}

	// Convert existing cmdline to params
	existingParams := existingCmdline.ToParams()

	// Merge parameters (new ones override existing ones)
	existingParams.Merge(newParams)

	// Convert back to sorted command line string
	cfg.GrubCfg.Cmdline = model.ParamsToCmdline(existingParams)

	if err := processFile(cfg.GrubCfg); err != nil {
		return nil, fmt.Errorf("error updating %s: %v", cfg.GrubCfg.CustomGrubFilePath, err)
	}

	return GrubConclusion(cfg.GrubCfg.CustomGrubFilePath, existingCmdlineStr, cfg.GrubCfg.Cmdline), nil
}

// parseGrubCMDLineLinuxDefault extracts GRUB_CMDLINE_LINUX_DEFAULT from the GRUB config file.
func parseGrubCMDLineLinuxDefault(path string) (string, error) {
	grubMap, err := ParseDefaultGrubFile(path)
	if err != nil {
		return "", fmt.Errorf("failed to parse grub file: %v", err)
	}

	cmdline, ok := grubMap["GRUB_CMDLINE_LINUX_DEFAULT"]
	if !ok {
		log.Printf("GRUB_CMDLINE_LINUX_DEFAULT not found in %s", path)
		return "", nil // Return empty string, not an error
	}

	return cmdline, nil
}

// ParseDefaultGrubFile parses a GRUB default configuration file into key-value pairs.
func ParseDefaultGrubFile(f string) (map[string]string, error) {
	file, err := os.Open(f)
	if err != nil {
		return nil, fmt.Errorf("failed to open file %s: %v", f, err)
	}
	defer file.Close()

	params := make(map[string]string)
	scanner := bufio.NewScanner(file)
	lineNum := 0

	for scanner.Scan() {
		lineNum++
		line := strings.TrimSpace(scanner.Text())

		// Skip empty lines and comments
		if line == "" || strings.HasPrefix(line, "#") {
			continue
		}

		// Split the line into key and value
		parts := strings.SplitN(line, "=", 2)
		if len(parts) != 2 {
			log.Printf("Warning: skipping invalid line %d in %s: %s", lineNum, f, line)
			continue
		}

		// Trim spaces and quotes from the key and value
		key := strings.TrimSpace(parts[0])
		value := strings.TrimSpace(parts[1])
		value = utils.TrimSurroundingQuotes(value)

		// Warn about duplicates
		if existing, exists := params[key]; exists {
			log.Printf("Warning: duplicate key %s in %s (line %d). Previous value: %s, new value: %s",
				key, f, lineNum, existing, value)
		}

		params[key] = value
	}

	if err := scanner.Err(); err != nil {
		return nil, fmt.Errorf("error reading grub file %s: %v", f, err)
	}

	return params, nil
}

// processFile writes the GRUB configuration to the specified file.
var processFile = func(grub model.Grub) error {
	banner := "# This file is automatically generated by rt-conf, please do not edit\n"
	cmdline := fmt.Sprintf("GRUB_CMDLINE_LINUX_DEFAULT=\"%s\"\n", grub.Cmdline)

	content := banner + cmdline

	if err := os.WriteFile(grub.CustomGrubFilePath, []byte(content), 0o644); err != nil {
		return fmt.Errorf("failed to write to %s file: %v", grub.CustomGrubFilePath, err)
	}
	return nil
}
