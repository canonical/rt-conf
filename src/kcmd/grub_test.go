package kcmd

import (
	"fmt"
	"os"
	"path/filepath"
	"strings"
	"testing"

	"github.com/canonical/rt-conf/src/model"
)

func TestProcessFile(t *testing.T) {
	t.Run("Success", func(t *testing.T) {
		tmpDir := t.TempDir()
		filePath := filepath.Join(tmpDir, "grub")

		grub := model.Grub{
			GrubDropInFile: filePath,
			Cmdline:        "isolcpus=1-3 nohz=on",
		}

		err := processFile(grub)
		if err != nil {
			t.Fatalf("unexpected error: %v", err)
		}

		content, err := os.ReadFile(filePath)
		if err != nil {
			t.Fatalf("failed to read file: %v", err)
		}

		expectedBanner := "# This file is automatically generated by rt-conf, please do not edit"
		if !strings.Contains(string(content), expectedBanner) {
			t.Errorf("expected banner %q, got:\n%s", expectedBanner, string(content))
		}

		expectedCmdline := `GRUB_CMDLINE_LINUX_DEFAULT="${GRUB_CMDLINE_LINUX_DEFAULT} isolcpus=1-3 nohz=on"`
		if !strings.Contains(string(content), expectedCmdline) {
			t.Errorf("expected cmdline %q, got:\n%s", expectedCmdline, string(content))
		}
	})

	t.Run("FailToWriteFile", func(t *testing.T) {
		// Try writing to a directory that doesn't exist
		badPath := filepath.Join("/nonexistent-dir", "grub")

		grub := model.Grub{
			GrubDropInFile: badPath,
			Cmdline:        "isolcpus=0",
		}

		err := processFile(grub)
		if err == nil {
			t.Fatal("expected error, got nil")
		}

		if !strings.Contains(err.Error(), "failed to write to") {
			t.Errorf("unexpected error message: %v", err)
		}
	})
}

func TestUpdateGrub(t *testing.T) {
	tests := []struct {
		name         string
		kcmd         model.KernelCmdline
		expectErr    string
		expectOutput string
		envVars      map[string]string
	}{
		{
			name:      "No params to inject",
			kcmd:      model.KernelCmdline{},
			expectErr: "no parameters to inject",
			envVars: map[string]string{
				"GRUB_DROPIN_FILE": "/tmp/60-rt-conf.cfg",
			},
		},
		{
			name: "detected bootloader GRUB",
			kcmd: model.KernelCmdline{
				Parameters: []string{
					"isolcpus=1-3",
				},
			},
			expectOutput: "Detected bootloader: GRUB",
			envVars: map[string]string{
				"GRUB_DROPIN_FILE": "/tmp/60-rt-conf.cfg",
			},
		},
		{
			name: "ProcessFile fails",
			kcmd: model.KernelCmdline{
				Parameters: []string{
					"nohz=on",
				},
			},
			expectErr: "error updating",
			envVars: map[string]string{
				"GRUB_DROPIN_FILE": "/tmp/60-rt-conf.cfg",
			},
		},
		{
			name: "Success",
			kcmd: model.KernelCmdline{
				Parameters: []string{
					"isolcpus=1-3",
					"nohz=on",
				},
			},
			expectOutput: "Detected bootloader: GRUB",
			envVars: map[string]string{
				"GRUB_DROPIN_FILE": "/tmp/60-rt-conf.cfg",
			},
		},
		{
			name: "duplicate parameters with different values",
			kcmd: model.KernelCmdline{
				Parameters: []string{
					"isolcpus=1-3",
					"nohz=on",
					"nohz=off",
				},
			},
			expectErr: "invalid new parameters",
			envVars: map[string]string{
				"GRUB_DROPIN_FILE": "/tmp/60-rt-conf.cfg",
			},
		},
		{
			name: "GRUB_DROPIN_FILE not set",
			kcmd: model.KernelCmdline{
				Parameters: []string{
					"isolcpus=1-3",
					"nohz=on",
				},
			},
			expectErr: "environment variable not set",
		},
	}

	for _, tc := range tests {
		t.Run(tc.name, func(t *testing.T) {
			tmpDir := t.TempDir()
			cfgPath := filepath.Join(tmpDir, "rt-conf.cfg")

			if tc.envVars != nil {
				for tck, v := range tc.envVars {
					if err := os.Setenv(tck, v); err != nil {
						t.Fatalf("failed to set env var %s: %v", tck, err)
					}
				}
			}

			// Unset env vars after the test
			t.Cleanup(func() {
				for tck := range tc.envVars {
					if err := os.Unsetenv(tck); err != nil {
						t.Fatalf("failed to unset env var %s: %v", tck, err)
					}
				}
			})

			conf := &model.InternalConfig{
				Data: model.Config{
					KernelCmdline: tc.kcmd,
				},
				GrubCfg: model.Grub{
					GrubDropInFile: cfgPath,
				},
			}

			if strings.Contains(tc.name, "ProcessFile fails") {
				processFile = func(_ model.Grub) error {
					return fmt.Errorf("mock write failure")
				}
			} else {
				processFile = func(_ model.Grub) error {
					// simulate a successful file process
					return nil
				}
			}

			msgs, err := UpdateGrub(conf)
			if tc.expectErr != "" {
				if err == nil || !strings.Contains(err.Error(), tc.expectErr) {
					t.Fatalf("expected error: %q, got: %q", tc.expectErr, err)
				}
			} else {
				if err != nil {
					t.Fatalf("unexpected error: %v", err)
				}
				found := false
				for _, msg := range msgs {
					if strings.Contains(msg, tc.expectOutput) {
						found = true
						break
					}
				}
				if !found {
					t.Fatalf("expected output to contain %q, got %v", tc.expectOutput, msgs)
				}
			}
		})
	}
}
