package kcmd

import (
	"fmt"
	"os"
	"path/filepath"
	"strings"
	"testing"

	"github.com/canonical/rt-conf/src/model"
)

func TestProcessFile(t *testing.T) {
	t.Run("Success", func(t *testing.T) {
		tmpDir := t.TempDir()
		filePath := filepath.Join(tmpDir, "grub")

		grub := model.Grub{
			CustomGrubFilePath: filePath,
			Cmdline:            "isolcpus=1-3 nohz=on",
		}

		err := processFile(grub)
		if err != nil {
			t.Fatalf("unexpected error: %v", err)
		}

		content, err := os.ReadFile(filePath)
		if err != nil {
			t.Fatalf("failed to read file: %v", err)
		}

		expectedBanner := "# This file is automatically generated by rt-conf, please do not edit"
		if !strings.Contains(string(content), expectedBanner) {
			t.Errorf("expected banner %q, got:\n%s", expectedBanner, string(content))
		}

		expectedCmdline := `GRUB_CMDLINE_LINUX_DEFAULT="${GRUB_CMDLINE_LINUX_DEFAULT} isolcpus=1-3 nohz=on"`
		if !strings.Contains(string(content), expectedCmdline) {
			t.Errorf("expected cmdline %q, got:\n%s", expectedCmdline, string(content))
		}
	})

	t.Run("FailToWriteFile", func(t *testing.T) {
		// Try writing to a directory that doesn't exist
		badPath := filepath.Join("/nonexistent-dir", "grub")

		grub := model.Grub{
			CustomGrubFilePath: badPath,
			Cmdline:            "isolcpus=0",
		}

		err := processFile(grub)
		if err == nil {
			t.Fatal("expected error, got nil")
		}

		if !strings.Contains(err.Error(), "failed to write to") {
			t.Errorf("unexpected error message: %v", err)
		}
	})
}

func setupTempFile(t *testing.T, content string, idex int) string {
	t.Helper()

	tmpFile, err := os.CreateTemp("", fmt.Sprintf("tempfile-%d", idex))
	if err != nil {
		t.Fatalf("Failed to create temporary file: %v", err)
	}

	if _, err := tmpFile.Write([]byte(content)); err != nil {
		t.Fatalf("Failed to write to temporary file: %v", err)
	}
	if err := tmpFile.Close(); err != nil {
		t.Fatal(err)
	}

	return tmpFile.Name()
}

func TestDuplicatedParams(t *testing.T) {
	testCases := []struct {
		name    string
		cmdline string
		err     string
	}{
		{
			name:    "No duplicates",
			cmdline: "quiet splash foo",
		},
		{
			name:    "Single parameter",
			cmdline: "quiet",
		},
		{
			name:    "Duplicate boolean parameters",
			cmdline: "quiet splash quiet",
		},
		{
			name:    "Duplicate keys with different values",
			cmdline: "potato=mashed potato=salad",
			err:     "duplicate parameter",
		},
		{
			name:    "Duplicate key-value pairs",
			cmdline: "potato=pie potato=pie",
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			kcmdline := model.NewKernelCmdline(tc.cmdline)
			err := kcmdline.HasDuplicates()
			if tc.err != "" {
				if err == nil {
					t.Fatalf("Expected error %v, got nil", tc.err)
				}
				if !strings.Contains(err.Error(), tc.err) {
					t.Fatalf("Expected error %q, got %q", tc.err, err.Error())
				}
				return
			}
			if err != nil {
				t.Fatalf("Expected no error, got %v", err)
			}
		})
	}
}

func TestUpdateGrub(t *testing.T) {
	tests := []struct {
		name         string
		kcmd         model.KernelCmdline
		expectErr    string
		expectOutput string
	}{
		{
			name:      "No params to inject",
			kcmd:      model.KernelCmdline{},
			expectErr: "no parameters to inject",
		},
		{
			name: "GRUB_CMDLINE_LINUX_DEFAULT missing",
			kcmd: model.KernelCmdline{
				Parameters: []string{
					"isolcpus=1-3",
				},
			},
			expectOutput: "Detected bootloader: GRUB",
		},
		{
			name: "ProcessFile fails",
			kcmd: model.KernelCmdline{
				Parameters: []string{
					"nohz=on",
				},
			},
			expectErr: "error updating",
		},
		{
			name: "Success",
			kcmd: model.KernelCmdline{
				Parameters: []string{
					"isolcpus=1-3",
					"nohz=on",
				},
			},
			expectOutput: "Detected bootloader: GRUB",
		},
	}

	for _, tc := range tests {
		t.Run(tc.name, func(t *testing.T) {
			tmpDir := t.TempDir()
			grubDefaultPath := filepath.Join(tmpDir, "grub")
			cfgPath := filepath.Join(tmpDir, "rt-conf.cfg")

			conf := &model.InternalConfig{
				Data: model.Config{
					KernelCmdline: tc.kcmd,
				},
				GrubCfg: model.Grub{
					GrubDefaultFilePath: grubDefaultPath,
					CustomGrubFilePath:  cfgPath,
				},
			}

			if strings.Contains(tc.name, "ProcessFile fails") {
				processFile = func(_ model.Grub) error {
					return fmt.Errorf("mock write failure")
				}
			} else {
				processFile = func(_ model.Grub) error {
					// simulate a successful file process
					return nil
				}
			}

			msgs, err := UpdateGrub(conf)
			if tc.expectErr != "" {
				if err == nil || !strings.Contains(err.Error(), tc.expectErr) {
					t.Fatalf("expected error: %q, got: %q", tc.expectErr, err)
				}
			} else {
				if err != nil {
					t.Fatalf("unexpected error: %v", err)
				}
				found := false
				for _, msg := range msgs {
					if strings.Contains(msg, tc.expectOutput) {
						found = true
						break
					}
				}
				if !found {
					t.Fatalf("expected output to contain %q, got %v", tc.expectOutput, msgs)
				}
			}
		})
	}
}
